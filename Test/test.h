void test1();
void test2();
void test3();
void test4();
void test5();
void test6();
void test7();
void test8();
void test9();

/*
C++: чем отличается указатель от ссылки?

1. Нельзя объявить массив ссылок.
2. У ссылки нет адреса.
3. Существует арифметика указателей, но нет арифметики ссылок.
4. Указатель может иметь «невалидное» значение с которым
его можно сравнить перед использованием.


1. Указатель может быть переназначен любое количество раз,
в то время как ссылка после привязки не может быть перемещена
 на другую ячейку памяти.

2. Указатели могут указывать "в никуда" (быть равными NULL),
в то время как ссылка всегда указывает на определенный объект.
GCC может без выдачи предупреждений обработать код наподобие
int &x = *(int*)0;, однако поведение подобного кода может
быть непредсказуемым.

3. Вы не можете получить адрес ссылки, как можете это делать
с указателями.

4. Не существует арифметики ссылок, в то время как существует
арифметика указателей. Однако есть возможность получить адрес
объекта, указанного по ссылке, и применить к этому адресу
арифметику указателей (например &obj + 5).


*/
/*
Что такое int (* m1)() ?
указатель на функцию которая не имеет агрументов и возвращает целое
Что такое float (*(* m2)(int, float))(int) ?
указатель на функцию которая пренимает int и float и возвращает
указатель на функцию которая принимает int и возвращает float
*/

/*
чем отличается unique_ptr от shared_ptr?

1. Используйте unique_ptr , если вам нужен один указатель на объект,
который будет восстановлен при уничтожении этого единственного указателя.
2. Используйте shared_ptr , если вам нужно несколько указателей на один
и тот же ресурс.

*/
